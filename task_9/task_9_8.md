# Домашнее задание 9

**Выполнил - Третьяков Александр Юрьевич**

## Упражение 6

### Задание
Замена коррелированного подзапроса соединением таблиц является одним из
способов повышения производительности.
Предположим, что мы задались вопросом: сколько маршрутов обслуживают самолеты каждого типа? При этом нужно учитывать, что может иметь место такая
ситуация, когда самолеты какого-либо типа не обслуживают ни одного маршрута. Поэтому необходимо использовать не только представление «Маршруты»
(`routes`), но и таблицу «Самолеты» (`aircrafts`).
Это первый вариант запроса, в нем используется коррелированный подзапрос.
```sql
EXPLAIN ANALYZE
    SELECT a.aircraft_code AS a_code,
           a.model,
           ( SELECT count( r.aircraft_code )
             FROM routes r
             WHERE r.aircraft_code = a.aircraft_code
           ) AS num_routes
    FROM aircrafts a
    GROUP BY 1, 2
    ORDER BY 3 DESC;
```
А в этом варианте коррелированный подзапрос раскрыт и заменен внешним
соединением:
```sql
EXPLAIN ANALYZE
    SELECT a.aircraft_code AS a_code,
           a.model,
           count( r.aircraft_code ) AS num_routes
    FROM aircrafts a
    LEFT OUTER JOIN routes r
        ON r.aircraft_code = a.aircraft_code
    GROUP BY 1, 2
    ORDER BY 3 DESC;
```
Причина использования внешнего соединения в том, что может найтись модель самолета, не обслуживающая ни одного маршрута, и если не использовать
внешнее соединение, она вообще не попадет в результирующую выборку.
Исследуйте планы выполнения обоих запросов. Попытайтесь найти объяснение различиям в эффективности их выполнения. Чтобы получить усредненную
картину, выполните каждый запрос несколько раз. Поскольку таблицы, участвующие в запросах, небольшие, то различие по абсолютным затратам времени
выполнения будет незначительным. Но если бы число строк в таблицах было
большим, то экономия ресурсов сервера могла оказаться заметной.
Предложите аналогичную пару запросов к базе данных «Авиаперевозки». Проведите необходимые эксперименты с вашими запросами.

### Решение

Исследуем планы выполнения обоих запросов

Коррелированный подзапрос

<img src="./assets/ex_8/2025-11-22 133233.jpg" width="900">

Запрос с внешним соединением

<img src="./assets/ex_8/2025-11-22 133452.jpg" width="900">

Анализ планов выполнения
1. Различия 

    - Коррелированный подзапрос (7.997 ms)
        - Выполняет `N+1` сканирований (где `N` - количество самолетов)
        - Для каждой строки `aircrafts` выполняется полное сканирование `routes` с фильтрацией
        - Общее количество обработанных строк: 9 × 710 = 6390

    - `LEFT JOIN`:
        - Выполняет однократное сканирование обеих таблиц
        - Использует хэш-соединение для эффективного объединения
        - Обрабатывает ровно 711 строк (результат соединения)

2. Парадокс производительности
Несмотря на то, что:
    - `Cost JOIN` (46.83) в 8 раз ниже, чем у подзапроса (371.31)
    - Фактическое время выполнения `JOIN` (15.94 ms) в 2 раза выше

Объяснение:

- Для маленьких таблиц накладные расходы операций (построение хэш-таблицы, агрегация) преобладают над вычислительной сложностью
- Коррелированный подзапрос избегает этих накладных расходов за счет многократных простых операций


**Выполним запросы несколько раз.**
Скриншоты прикладывать не имеет смысла, из за однотипности результата.
Итоговые данные приведены в таблице.

| Запрос               | Запуск 1   | Запуск 2       | Запуск 3       | Запуск 4       | Среднее    | Отклонение         |
|----------------------|------------|----------------|----------------|----------------|------------|--------------------|
| Коррелированный подзапрос | 7.997 ms   | 10.976 ms (+37%) | 11.449 ms (+43%) | 8.014 ms (+0%)  | 9.609 ms   | ±1.8 ms (19%)      |
| LEFT JOIN            | 15.942 ms  | 19.710 ms (+24%) | 15.479 ms (-3%)  | 25.821 ms (+62%)| 19.238 ms  | ±4.7 ms (24%)      |

Для данного конкретного случая (маленькие таблицы):

- Коррелированный подзапрос значительно эффективнее - в 2 раза быстрее

- Производительность подзапроса более стабильна - меньший разброс результатов

- `JOIN` проигрывает из-за накладных расходов на маленьких объемах данных

- Планировщик `PostgreSQL` недооценивает эффективность коррелированных подзапросов для маленьких таблиц

Возьмем для дальнейшего анализа следующие запросы

**Коррелированный подзапрос (билеты по классам обслуживания)**

```sql
EXPLAIN ANALYZE
SELECT f.fare_conditions,
       (SELECT COUNT(*) 
        FROM ticket_flights tf 
        WHERE tf.fare_conditions = f.fare_conditions) as ticket_count
FROM (SELECT DISTINCT fare_conditions FROM seats) f
ORDER BY ticket_count DESC;
```

**Запрос с внешним соединением (билеты по классам обслуживания)**

```sql
EXPLAIN ANALYZE
SELECT s.fare_conditions,
       COUNT(tf.ticket_no) as ticket_count
FROM (SELECT DISTINCT fare_conditions FROM seats) s
LEFT JOIN ticket_flights tf ON tf.fare_conditions = s.fare_conditions
GROUP BY s.fare_conditions
ORDER BY ticket_count DESC;
```
<img src="./assets/ex_8/2025-11-22 140309.jpg" width="900">

<img src="./assets/ex_8/2025-11-22 140331.jpg" width="900">

Скриншоты всех запусков выполнения прикладывать не имеет смысла, из за однотипности результата.
Итоговые данные приведены в таблице.

| Запрос               | Запуск 1       | Запуск 2           | Запуск 3           | Запуск 4           | Среднее        | Отклонение           |
|----------------------|----------------|--------------------|--------------------|--------------------|----------------|----------------------|
| Коррелированный подзапрос | 9897.088 ms    | 9374.439 ms (-5%)   | 9374.140 ms (-5%)   | 9823.793 ms (-1%)   | 9617.365 ms    | ±245 ms (2.5%)       |
| LEFT JOIN            | 18649.272 ms   | 18807.465 ms (+1%)  | 18562.448 ms (-0.5%)| 18527.685 ms (-0.6%)| 18636.718 ms   | ±125 ms (0.7%)       |

Результаты выполнения запросов

<img src="./assets/ex_8/2025-11-22 142952.jpg" width="900">

Причины превосходства коррелированного подзапроса
1. Эффективность фильтрации
    - Подзапрос: Каждый из 3 подзапросов читает только нужные строки (348,575 из 1,045,726)
    - JOIN: Читает всю таблицу ticket_flights целиком (1,045,726 строк)

2. Локальность данных
    - Подзапрос обрабатывает данные по категориям последовательно
    - JOIN требует полного сканирования большой таблицы

3. Отсутствие накладных расходов соединения
Подзапрос избегает:
    - Построения хэш-таблицы
    - Операции Hash Join
    - Дополнительной агрегации большого набора данных

4. Оптимизация планировщика
    - Cost подзапроса: 68,181.86 (завышен)
    - Cost JOIN: 31,109.68 (занижен)

Парадокс стоимостной оценки
JOIN имеет в 2.2 раза меньший cost (31,109 vs 68,181)
Но выполняется в 1.94 раза дольше (18.6 сек vs 9.6 сек)

Планировщик не учитывает эффективность последовательной обработки маленьких подмножеств

**Итоговый вывод**
Для больших таблиц с высокой селективностью по категориям, для запросов с группировкой по категориям стоит предпочитать коррелированные подзапросы, особенно когда количество категорий невелико.