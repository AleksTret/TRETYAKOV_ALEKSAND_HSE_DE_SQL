# Домашнее задание 8

**Выполнил - Третьяков Александр Юрьевич**

## Упражение 3

### Задание
Когда говорят о таком феномене, как потерянное обновление, то зачастую в качестве примера приводится операция `UPDATE`, в которой значение какого-то
атрибута изменяется с применением одного из действий арифметики. Например:
```sql
UPDATE aircrafts_tmp
    SET range = range + 200
    WHERE aircraft_code = 'CR2';
```
При выполнении двух и более подобных обновлений в рамках параллельных
транзакций, использующих, например, уровень изоляции `Read Committed`, будут учтены все такие изменения (что и было показано в тексте главы). Очевидно, что потерянного обновления не происходит.
Предположим, что в одной транзакции будет просто присваиваться новое значение, например, так:
```sql
UPDATE aircrafts_tmp
    SET range = 2100
    WHERE aircraft_code = 'CR2';
```
А в параллельной транзакции будет выполняться аналогичная команда:
```sql
UPDATE aircrafts_tmp
    SET range = 2500
    WHERE aircraft_code = 'CR2';
```
Очевидно, что сохранится только одно из значений атрибута `range`. Можно ли
говорить, что в такой ситуации имеет место потерянное обновление? Если оно
имеет место, то что можно предпринять для его недопущения? Обоснуйте ваш
ответ.
Для получения дополнительной информации можно обратиться к фундаментальному труду К. Дж. Дейта, а также к полному руководству по `SQL` Дж. Гроффа,
П. Вайнберга и Э. Оппеля. Библиографические описания этих книг приведены
в списке рекомендуемой литературы.
### Решение

Выполним в двух терминалах предложенные операции `UPDATE`

```sql
UPDATE aircrafts_tmp
    SET range = 2100
    WHERE aircraft_code = 'CR2';
```

```sql
UPDATE aircrafts_tmp
    SET range = 2500
    WHERE aircraft_code = 'CR2';
```
Терминал 1

<img src="./assets/ex_3/2025-11-17 201129.jpg" width="500">

Терминал 2

<img src="./assets/ex_3/2025-11-17 201152.jpg" width="500">

Выполним `COMMIT` транзакции в первом терминале и проверим результат во втором.

<img src="./assets/ex_3/2025-11-17 201454.jpg" width="500">

Как видно можно говорить о ситуации с потерянным обновлением.

Потерянное обновление происходит, когда две транзакции читают одни и те же данные, затем обе обновляют их, но второе обновление перезаписывает первое, "теряя" его результат.

Что происходит в нашем примере:
- Транзакция 1 UPDATE ... SET range = 2100
- Транзакция 2: UPDATE ... SET range = 2500

Результат: сохранится только значение из последней зафиксированной транзакции

Первое обновление будет полностью потеряно

Для предотвращения ситуации с потерянным обновлением можно изменить уровень изоляции на `REPEATABLE READ`

Выполним в терминале 1
```sql
BEGIN ISOLATION LEVEL REPEATABLE READ;

SELECT range FROM aircrafts_tmp WHERE aircraft_code = 'CR2';

UPDATE aircrafts_tmp SET range = 2100 WHERE aircraft_code = 'CR2';
```
<img src="./assets/ex_3/2025-11-17 203550.jpg" width="600">

Выполним в терминале 2

```sql
BEGIN ISOLATION LEVEL REPEATABLE READ;

SELECT range FROM aircrafts_tmp WHERE aircraft_code = 'CR2';

UPDATE aircrafts_tmp SET range = 2500 WHERE aircraft_code = 'CR2';
```
<img src="./assets/ex_3/2025-11-17 203921.jpg" width="600">

Выполням `COMMIT` в терминале 1 и проверяем результат в терминале 2.

<img src="./assets/ex_3/2025-11-17 204026.jpg" width="600">

Транзация в терминале 2 не может быть завершена из за нарушения уровня изоляции и потери обновления в терминале 1 не происходит

<img src="./assets/ex_3/2025-11-17 204231.jpg" width="600">

Так же можно было использовать уровень изоляции `SERIALIZABLE`

Уровни `Repeatable Read` и `Serializable` гарантируют соблюдение свойства `Isolation` (изолированность) в стандарте `ACID`

Использование строгих уровней изоляции является корректным решением потому, что:
- Соответствует теории (стандарты ACID, SQL)
- Технически реализуемо (поддержка в PostgreSQL)
- Практически применимо (простота реализации)
