# Домашнее задание 8

**Выполнил - Третьяков Александр Юрьевич**

## Упражение 2

### Задание
Транзакции, работающие на уровне изоляции `Read Committed`, видят только
свои собственные обновления и обновления, зафиксированные параллельными
транзакциями. При этом нужно учитывать, что иногда могут возникать ситуации, которые на первый взгляд кажутся парадоксальными, но на самом деле
все происходит в строгом соответствии с этим принципом.
Воспользуемся таблицей «Самолеты» (`aircrafts`) или ее копией. Предположим, что мы решили удалить из таблицы те модели, дальность полета которых
менее 2 000 км. В таблице представлена одна такая модель — `Cessna 208 Caravan`,
имеющая дальность полета 1 200 км. Для выполнения удаления мы организовали транзакцию. Однако параллельная транзакция, которая, причем, началась
раньше, успела обновить таблицу таким образом, что дальность полета самолета `Cessna 208 Caravan` стала составлять 2 100 км, а вот для самолета `Bombardier
CRJ-200` она, напротив, уменьшилась до 1 900 км. Таким образом, в результате
выполнения операций обновления в таблице по-прежнему присутствует строка, удовлетворяющая первоначальному условию, т. е. значение атрибута `range`
у которой меньше 2000.
Наша задача: проверить, будет ли в результате выполнения двух транзакций
удалена какая-либо строка из таблицы.
На первом терминале начнем транзакцию, при этом уровень изоляции `Read
Committed` в команде указывать не будем, т. к. он принят по умолчанию:
```sql
BEGIN;
BEGIN

SELECT *
    FROM aircrafts_tmp
    WHERE range < 2000;

aircraft_code  | model              | range
---------------+--------------------+-------
CN1            | Cessna 208 Caravan | 1200
(1 строка)

UPDATE aircrafts_tmp
    SET range = 2100
    WHERE aircraft_code = 'CN1';

UPDATE 1

UPDATE aircrafts_tmp
    SET range = 1900
    WHERE aircraft_code = 'CR2';

UPDATE 1
```
На втором терминале начнем вторую транзакцию, которая и будет пытаться
удалить строки, у которых значение атрибута `range` меньше 2000.


```sql
BEGIN;
BEGIN

SELECT *
    FROM aircrafts_tmp
    WHERE range < 2000;

aircraft_code  | model              | range
---------------+--------------------+-------
CN1            | Cessna 208 Caravan | 1200
(1 строка)

DELETE FROM aircrafts_tmp WHERE range < 2000;
```
Введя команду `DELETE`, мы видим, что она не завершается, а ожидает, когда со
строки, подлежащей удалению, будет снята блокировка. Блокировка, установленная командой `UPDATE` в первой транзакции, снимается только при завершении транзакции, а завершение может иметь два исхода: фиксацию изменений с помощью команды `COMMIT` (или `END`) или отмену изменений с помощью
команды `ROLLBACK`.

Давайте зафиксируем изменения, выполненные первой транзакцией. На первом терминале сделаем так:
```sql
COMMIT;
COMMIT
```
Тогда на втором терминале мы получим такой результат от команды `DELETE`
```sql
DELETE 0
```
Чем объясняется такой результат? Он кажется нелогичным: ведь команда
`SELECT`, выполненная в этой же второй транзакции, показывала наличие строки, удовлетворяющей условию удаления.
Объяснение таково: поскольку вторая транзакция пока еще не видит изменений, произведенных в первой транзакции, то команда `DELETE` выбирает для
удаления строку, описывающую модель `Cessna 208 Caravan`, однако эта строка
была заблокирована в первой транзакции командой `UPDATE`. Эта команда изменила значение атрибута `range` в этой строке.
При завершении первой транзакции блокировка с этой строки снимается (со
второй строки — тоже), и команда `DELETE` во второй транзакции получает возможность заблокировать эту строку. При этом команда `DELETE` данную строку
перечитывает и вновь вычисляет условие `WHERE` применительно к ней. Однако
теперь условие `WHERE` для данной строки уже не выполняется, следовательно,
эту строку удалять нельзя. Конечно, в таблице есть теперь другая строка, для
самолета `Bombardier CRJ-200`, удовлетворяющая условию удаления, однако повторный поиск строк, удовлетворяющих условию `WHERE` в команде `DELETE`, не
производится.
В результате не удаляется ни одна строка. Таким образом, к сожалению, имеет
место нарушение согласованности, которое можно объяснить деталями реализации СУБД.
Завершим вторую транзакцию:

Завершим вторую транзакцию:
```sql
END;
COMMIT
```
Вот что получилось в результате:
```sql
SELECT * FROM aircrafts_tmp;

aircraft_code  | model               | range
---------------+---------------------+-------
773            | Boeing 777-300      | 11100
763            | Boeing 767-300      | 7900
SU9            | Sukhoi SuperJet-100 | 3000
320            | Airbus A320-200     | 5700
321            | Airbus A321-200     | 5600
319            | Airbus A319-100     | 6700
733            | Boeing 737-300      | 4200
CN1            | Cessna 208 Caravan  | 2100
CR2            | Bombardier CRJ-200  | 1900
(9 строк)

```
**Задание**. Модифицируйте сценарий выполнения транзакций: в первой транзакции вместо фиксации изменений выполните их отмену с помощью команды
`ROLLBACK` и посмотрите, будет ли удалена строка и какая конкретно.

### Решение

Поработаем с таблицей `aircrafts_tmp`

Выполним в терминале 1.

```sql
BEGIN;

SELECT * FROM aircrafts_tmp WHERE range < 2000;

UPDATE aircrafts_tmp SET range = 2100 WHERE aircraft_code = 'CN1';

UPDATE aircrafts_tmp SET range = 1900 WHERE aircraft_code = 'CR2';
```
<img src="./assets/ex_2/2025-11-17 192725.jpg" width="700">

Выполним в терминале 2
```sql
BEGIN;

SELECT * FROM aircrafts_tmp WHERE range < 2000;

DELETE FROM aircrafts_tmp WHERE range < 2000;
```
<img src="./assets/ex_2/2025-11-17 192815.jpg" width="700">

Завершим транзакцию в терминале 1. И можем увидеть что в терминале 2 действительно удалено 0 строк.

<img src="./assets/ex_2/2025-11-17 193051.jpg" width="700">
<img src="./assets/ex_2/2025-11-17 193149.jpg" width="700">

Завершим транзакцию в терминале 2 и проверим результат `UPDATE` в терминале 1.

<img src="./assets/ex_2/2025-11-17 193354.jpg" width="600">

Модифицируем сцинарий транзакции и проверим результат

Подготовим данные
```sql
DROP TABLE aircrafts_tmp;

CREATE TABLE aircrafts_tmp AS 
SELECT * FROM aircrafts;
```
<img src="./assets/ex_2/2025-11-17 193826.jpg" width="600">

Выполним в терминале 1.

```sql
BEGIN;

SELECT * FROM aircrafts_tmp WHERE range < 2000;

UPDATE aircrafts_tmp SET range = 2100 WHERE aircraft_code = 'CN1';

UPDATE aircrafts_tmp SET range = 1900 WHERE aircraft_code = 'CR2';
```
<img src="./assets/ex_2/2025-11-17 194126.jpg" width="700">

Выполним в терминале 2.
```sql
BEGIN;

SELECT * FROM aircrafts_tmp WHERE range < 2000;

DELETE FROM aircrafts_tmp WHERE range < 2000;
```
<img src="./assets/ex_2/2025-11-17 194309.jpg" width="700">

Выполним `ROLLBACK` в терминале 1.

<img src="./assets/ex_2/2025-11-17 194416.jpg" width="600">

Операция удаления в терминале 2 завершится успешно. И количество записей в таблице `aircrafts_tmp` уменьшиться.

<img src="./assets/ex_2/2025-11-17 194534.jpg" width="700">

Что происходит в данном примере:

1. Терминал 1 (начинает первым):

- Начинает транзакцию
- Видит самолет `Cessna` с дальностью 1200 км
- Обновляет `Cessna` до 2100 км (блокирует строку)
- Обновляет `Bombardier` до 1900 км (блокирует строку)
- Выполняет `ROLLBACK` - откатывает оба изменения, снимает блокировки

2. Терминал 2 (начинает позже):

- Начинает транзакцию
- Видит только `Cessna` с 1200 км (изменения T1 еще не видны)
- Пытается удалить самолеты с дальностью < 2000 км - блокируется в ожидании Cessna
- После `ROLLBACK` в T1: получает доступ к `Cessna`, проверяет ее - видит 1200 км, удаляет ее

Результат: `DELETE 1` - удалена строка `Cessna`

Итог: Удален только самолет `Cessna 208 Caravan`, так как после отката транзакции 1 он остался с исходной дальностью 1200 км.