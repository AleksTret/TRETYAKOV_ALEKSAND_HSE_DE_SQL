# Домашнее задание 7

**Выполнил - Третьяков Александр Юрьевич**

## Упражение 3

### Задание
Известно, что индекс значительно ускоряет работу, если при выполнении запроса из таблицы отбирается лишь небольшая часть строк. Если же эта доля
велика, скажем, половина строк или более, то большого положительного эффекта от наличия индекса уже не будет, а возможно даже, что не будет практически
никакого эффекта. Наша задача — проверить это утверждение на практике.
Обратимся к таблице «Перелеты» (`ticket_flights`). В ней имеется столбец
«Класс обслуживания» (`fare_conditions`), который отличается от остальных
тем, что в нем могут присутствовать лишь три различных значения: `Comfort`,
`Business` и `Economy`.
Если секундомер в утилите `psql` выключен, то включите его.
Выполните запросы, подсчитывающие количество строк, в которых атрибут
`fare_conditions` принимает одно из трех возможных значений. Каждый из
запросов выполните три-четыре раза, поскольку время может немного изменяться, и подсчитайте среднее время. Обратите внимание на число строк, которые возвращает функция `count` для каждого значения атрибута. При этом
среднее время выполнения запросов для трех различных значений атрибута
`fare_conditions` будет различаться незначительно, поскольку в каждом случае СУБД просматривает все строки таблицы.
```sql
SELECT count( * )
    FROM ticket_flights
    WHERE fare_conditions = 'Comfort';

SELECT count( * )
    FROM ticket_flights
    WHERE fare_conditions = 'Business';

SELECT count( * )
    FROM ticket_flights
    WHERE fare_conditions = 'Economy'; 
```
Создайте индекс по столбцу `fare_conditions`. Конечно, в реальной ситуации
такой индекс вряд ли целесообразен, но нам он нужен для экспериментов.
Проделайте те же эксперименты с таблицей `ticket_flights`. Будет ли различаться среднее время выполнения запросов для различных значений атрибута
`fare_conditions`? Почему это имеет место?
В завершение этого упражнения отметим, что в случае ошибки планировщика при использовании индекса возможно не только отсутствие положительного
эффекта, но и значительный отрицательный эффект

### Решение

Включим секундомер и выполним первый запрос
```sql
SELECT count(*) FROM ticket_flights WHERE fare_conditions = 'Comfort';
```
Время выполнения второго и последующих запросов отличается больше чем в 4 раза, по причине кэширования таблицы на сервере postgres. Не будем его учитывать.

<img src="./assets/ex_3/2025-11-15 204610.jpg" width="700">

Аналогично выполним второй и третий запросы
```sql
SELECT count(*) FROM ticket_flights WHERE fare_conditions = 'Business';
```
<img src="./assets/ex_3/2025-11-15 204927.jpg" width="700">

```sql
SELECT count(*) FROM ticket_flights WHERE fare_conditions = 'Economy';
```
<img src="./assets/ex_3/2025-11-15 205108.jpg" width="700">

Перенесем данные о времени выполнения в таблицу и посчитаем среднее.

| `Comfort` | `Business` | `Economy` |
|-------------|-------------|-------------|
| `65.754`  | `64.125`   | `63.308`  |
| `58.096`   | `62.960`   | `61.574`   |
| `58.328`  |  `60.112`  |  `60.391`      |
| AVG | AVG | AVG |
|   `60.726`     |   `62.399`|  `61.758`       |

Время выполнения всех трех запросов примерно одинаковое. И количество строк выбираемых предикатом в `SELECT` не оказывает сильного влияния на него.

Создаем индекс по столбцу `fare_conditions`'

```sql
CREATE INDEX idx_ticket_flights_fare_cond ON booking.ticket_flights (fare_conditions);
```
<img src="./assets/ex_3/2025-11-15 211612.jpg" width="700">

<img src="./assets/ex_3/2025-11-15 211717.jpg" width="700">

Повторим выполнение

<img src="./assets/ex_3/2025-11-15 211847.jpg" width="700">
<img src="./assets/ex_3/2025-11-15 211926.jpg" width="700">
<img src="./assets/ex_3/2025-11-15 212004.jpg" width="700">

Перенесем данные о времени выполнения в таблицу и посчитаем среднее.

| `Comfort` | `Business` | `Economy` |
|-------------|-------------|-------------|
| `2.098`  | `9.171`   | `47.677`  |
| `1.766`   | `5.994`   | `33.305`   |
| `2.185`  |  `6.201`  |  `27.419`      |
| AVG | AVG | AVG |
|   `2.016`     |   `7.122`|  `36.134`       |

Ответим на вопрос из задачи - *Будет ли различаться среднее время выполнения запросов для различных значений атрибута `fare_conditions?` Почему это имеет место?*

Да, время выполнения запросов для различных значений атрибута `fare_conditions` и очень значительно. После создания индекса время выполнения перестанет быть константным и станет сильно зависеть от селективности запроса (т.е. от того, какую долю таблицы он возвращает).

Например для выборки по предикату `fare_conditions = 'Comfort'`
Планировщик запросов PostgreSQL скорее всего будет использовать `Index Scan`, потому что значение `Comfort` встречается редко, и не будет читать всю таблицу. В этом случае использование индекса целесообразно.

Проверим это в плане выполнения

```sql
EXPLAIN (ANALYZE, BUFFERS) 
SELECT count(*) FROM bookings.ticket_flights WHERE fare_conditions = 'Comfort';
```
<img src="./assets/ex_3/2025-11-15 215302.jpg" width="900">

В плане запроса мы можем видеть `Index Only Scan` - это даже лучше чем обычный `Index Scan`. PostgreSQL смог выполнить запрос только по индексу, без обращений к самой таблице (`heap`). Это происходит потому что:
- Индекс содержит все нужные данные (столбец `fare_conditions`)
- Нам нужно только подсчитать количество строк, а не получать сами данные
- `Heap Fetches: 0` - подтверждает, что не было обращений к основной таблице

Для выборки по предикату `fare_conditions = 'Business'` планировщик проводит анализ и может принять решение об использовании индекса или о полном сканировании, в зависимости от статистики.

```sql
EXPLAIN (ANALYZE, BUFFERS) 
SELECT count(*) FROM bookings.ticket_flights WHERE fare_conditions = 'Business';
```

<img src="./assets/ex_3/2025-11-15 220043.jpg" width="900">

Как видно из плана запроса для выборки по прежнему использован `Index Only Scan` 
При этом обращения к таблице  `Heap Fetches: 5` и количество прочитанных буферов `Buffers: shared hit=97` что больше чем для предиката `fare_conditions = 'Comfort'`

Для предиката `fare_conditions = 'Economy'` будет соответствовать большая часть строк таблицы, поэтому индекс скорее всего не будет использован. Потому что при индексном скане будет много случайных чтений из разных блоков и это медленее чем последовательное чтение. И можно предположить что будет использован `Seq Scan`

Посмотрим план запроса
```sql
EXPLAIN (ANALYZE, BUFFERS) 
SELECT count(*) FROM bookings.ticket_flights WHERE fare_conditions = 'Economy';
```

<img src="./assets/ex_3/2025-11-15 221330.jpg" width="900">

Но нет. 
Планировщик НЕ переключился на Seq Scan даже для самого частого значения
- `Parallel Index Only Scan` - планировщик все еще использует индекс, но теперь распараллеливает запрос
- `Workers Launched: 2` - запущено `2` рабочих процесса + основной процесс
- `Buffers: shared hit=782` - количество прочитанных буферов будет наибольшее

Из этого можно сделать вывод что - индекс достаточно эффективен даже для больших объемов данных

Удалим индекс, и посмотрим план запроса

<img src="./assets/ex_3/2025-11-15 222110.jpg" width="900">

<img src="./assets/ex_3/2025-11-15 222341.jpg" width="900">

С индексом (`Index Only Scan`):
- Время: 155.675 ms
- Буферы: 18 (только из памяти)
- Метод: `Index Only Scan`

Без индекса (`Parallel Seq Scan`):
- Время: 128.812 ms
- Буферы: 8776 (1251 из памяти + 7525 с диска)
- Метод: `Parallel Seq Scan`

Параллельное сканирование оказалось эффективнее 
`Seq Scan` читал много буферов (8776), но благодаря параллелизму справился быстрее

Это показывает, что индексы не всегда уменьшают время выборки, так как механизмы параллельного сканирования могут быть очень эффективны

Аналогично посмотрим
<img src="./assets/ex_3/2025-11-15 222852.jpg" width="900">

<img src="./assets/ex_3/2025-11-15 222914.jpg" width="900">


Сводка результатов (время выполнения в ms):
| Значение | С индексом | Без индекса | Разница                     |
|----------|------------|-------------|-----------------------------|
| Comfort  | 155.7 ms   | 128.8 ms    | ✅ Быстрее БЕЗ индекса      |
| Business | 921.7 ms   | 385.4 ms    | ✅ Быстрее БЕЗ индекса      |
| Economy  | 2906.5 ms  | 2870.0 ms   | ~ Одинаково                 |

Индекс не оказался полезным для этой таблицы
Для всех трех значений запросы выполнялись быстрее или одинаково БЕЗ индекса

Особенно заметна разница для `Business` - в `2.4` раза быстрее без индекса
Параллельное сканирование очень эффективно на современных многопроцессорных системах
`Index Only Scan` хоть и читает мало данных, но требует много случайных обращений
`Seq Scan` читает данные большими последовательными блоками, что оптимально для дисков

**То есть начальное утверждение из задачи
`индекс значительно ускоряет работу` - подтверждается с нюансом: индекс ускоряет работу если из таблицы отбирается лишь небольшая часть строк.**