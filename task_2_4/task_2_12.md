# Домашнее задание 4

**Выполнил - Третьяков Александр Юрьевич**

## Упражение 11

### Задание

Табличные функции в списке SELECT?
Иногда можно, но все же лучше в предложении FROM
Табличные функции можно вызывать в списке SELECT. Иногда это упрощает запрос, однако зачастую вызывает затруднения, которых не бывает при использовании функций в предложении FROM.

Давайте решим такую задачу: требуется сформировать списки городов, в которые есть рейсы из Томска, Красноярска, Кемерова и Новосибирска. Причем эти
списки нужно поместить в отдельные колонки, чтобы было удобно сопоставлять полученные результаты. Воспользуемся функцией list_connected_cities,
рассмотренной в предыдущем упражнении. Запрос будет таким:

```sql
SELECT
list_connected_cities( 'Томск' ) AS "Томск",
list_connected_cities( 'Красноярск' ) AS "Красноярск",
list_connected_cities( 'Кемерово' ) AS "Кемерово",
list_connected_cities( 'Новосибирск' ) AS "Новосибирск";

Томск           | Красноярск    | Кемерово | Новосибирск
−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−
Абакан          | Барнаул       | Кызыл    | Абакан
Архангельск     | Курган        | Москва   | Горно−Алтайск
Волгоград       | Москва        | Удачный  | Калуга
Москва          | Новокузнецк   |          | Киров
Новокузнецк     | Новосибирск   |          | Красноярск
Ростов−на−Дону  | Новый Уренгой |          | Магнитогорск
Ярославль       | Советский     |          | Мирный
                | Сочи          |          | Москва
                | Усть−Илимск   |          | Новокузнецк
                | Усть−Кут      |          | Пермь
                |               |          | Салехард
                |               |          | Сургут
                |               |          | Удачный
                |               |          | Ханты−Мансийск
(14 строк)
```

В разделе документации 36.5.9 «Функции SQL, возвращающие множества» сказано, что при вызове табличных функций в списке SELECT первая результирующая строка формируется из первых строк, возвращаемых функциями, вторая —
из вторых строк и так далее. Общее число строк определяется функцией, возвратившей больше всего строк, а результат остальных функций дополняется
при необходимости значениями NULL, как в нашем примере.

Можно получить такой же результат, вызывая функции не в списке SELECT,
а в предложении FROM с помощью конструкции ROWS FROM ( ... ), которую PostgreSQL предлагает как расширение стандарта SQL. Эта конструкция представлена в документации в описании команды SELECT и в подразделе 7.2.1.4 «Табличные функции». Вот каким станет запрос:

```sql
SELECT *
FROM ROWS FROM
( list_connected_cities( 'Томск' ),
list_connected_cities( 'Красноярск' ),
list_connected_cities( 'Кемерово' ),
list_connected_cities( 'Новосибирск' )
) AS lcc( "Томск", "Красноярск", "Кемерово", "Новосибирск" );

Томск           | Красноярск    | Кемерово | Новосибирск
−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−
Абакан          | Барнаул       | Кызыл    | Абакан
Архангельск     | Курган        | Москва   | Горно−Алтайск
Волгоград       | Москва        | Удачный  | Калуга
Москва          | Новокузнецк   |          | Киров
Новокузнецк     | Новосибирск   |          | Красноярск
Ростов−на−Дону  | Новый Уренгой |          | Магнитогорск
Ярославль       | Советский     |          | Мирный
                | Сочи          |          | Москва
                | Усть−Илимск   |          | Новокузнецк
                | Усть−Кут      |          | Пермь
                |               |          | Салехард
                |               |          | Сургут
                |               |          | Удачный
                |               |          | Ханты−Мансийск
(14 строк)
```

Обратите внимание на использование одинарных и двойных кавычек. Псевдонимы результирующих столбцов выборки можно было задать вообще без кавычек (хотя называть столбцы по-русски в принципе не рекомендуется):
```sql
...
) AS lcc( Томск, Красноярск, Кемерово, Новосибирск );
```

В обоих запросах не было предложения ORDER BY. При этом названия городов в каждой колонке оказались отсортированными, хотя и в коде функции
list_connected_cities также нет предложения ORDER BY. Это случайный результат. Но если бы в коде функции и была предусмотрена сортировка, полагаться
на то, что ее результат сохранится и на уровне всего запроса, нельзя. В описании
команды SELECT, приведенном в документации, сказано следующее: «Если присутствует предложение ORDER BY, возвращаемые строки сортируются в указанном порядке. В отсутствие ORDER BY строки возвращаются в том порядке, в каком системе будет проще их выдать». Напомним, что при использовании оконных функций также рекомендуется задавать предложение ORDER BY на верхнем
уровне запроса, а не полагаться на сортировку, выполненную при формировании окна. Об этом говорится в подразделе документации 7.2.5 «Обработка
оконных функций».

Но даже предложение ORDER BY в приведенных запросах не может гарантировать получение правильного результата, поскольку в нашем примере значения
в каждой колонке должны сортироваться независимо от других колонок, а предложение ORDER BY не может этого обеспечить.

Таким образом, рассмотренные решения поставленной задачи нельзя считать
корректными. Они были бы приемлемыми, если бы порядок сортировки не был
критичным.

Можно предложить решение с вызовом функций в предложении FROM:

```sql
WITH cities(col, city, num) AS
( SELECT 1, *
FROM list_connected_cities( 'Томск' ) WITH ORDINALITY
UNION ALL
SELECT 2, *
FROM list_connected_cities( 'Красноярск' ) WITH ORDINALITY
UNION ALL
SELECT 3, *
FROM list_connected_cities( 'Кемерово' ) WITH ORDINALITY
UNION ALL
SELECT 4, *
FROM list_connected_cities( 'Новосибирск' ) WITH ORDINALITY
)

SELECT num,
any_value( city ) FILTER ( WHERE col = 1 ) AS "Томск",
any_value( city ) FILTER ( WHERE col = 2 ) AS "Красноярск",
any_value( city ) FILTER ( WHERE col = 3 ) AS "Кемерово",
any_value( city ) FILTER ( WHERE col = 4 ) AS "Новосибирск"
FROM cities
GROUP BY num
ORDER BY num;

Томск           | Красноярск    | Кемерово | Новосибирск
−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−
Абакан          | Барнаул       | Кызыл    | Абакан
Архангельск     | Курган        | Москва   | Горно−Алтайск
Волгоград       | Москва        | Удачный  | Калуга
Москва          | Новокузнецк   |          | Киров
Новокузнецк     | Новосибирск   |          | Красноярск
Ростов−на−Дону  | Новый Уренгой |          | Магнитогорск
Ярославль       | Советский     |          | Мирный
                | Сочи          |          | Москва
                | Усть−Илимск   |          | Новокузнецк
                | Усть−Кут      |          | Пермь
                |               |          | Салехард
                |               |          | Сургут
                |               |          | Удачный
                |               |          | Ханты−Мансийск
(14 строк)
```

В списке SELECT, в отличие от предложения FROM, табличные функции могут
быть вложенными. В подразделе документации 36.5.9 «Функции SQL, возвращающие множества» приведен абстрактный пример использования таких конструкций (srf — set returning function):
```sql
SELECT
srf1( srf2( x ), srf3( y ) ),
srf4( srf5( z ) )
FROM tab;
```

Там сказано, что каждый уровень вложенности обрабатывается отдельно,
как будто он формируется с помощью отдельной конструкции LATERAL ROWS
FROM( ... ). В приведенном примере для каждой строки из таблицы tab сначала
будут вызваны функции srf2, srf3 и srf5, а затем для каждой комбинированной
строки, сформированной ими, будут вызваны функции srf1 и srf4. Конечно же,
все эти функции могут возвращать разное число строк; значения NULL в результирующих строках могут приводить к неожиданным результатам.

Давайте снова обратимся к примеру, рассмотренному в предыдущем упражнении, — определению степени заполнения самолетов на всех направлениях,
проложенных из городов часового пояса Asia/Vladivostok. Сначала покажем, куда можно улететь из этих городов:

```sql
SELECT city, list_connected_cities( city ) AS connected_city
FROM airports
WHERE timezone = 'Asia/Vladivostok'
ORDER BY city, connected_city;

city                  | connected_city
−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−
Владивосток           | Иркутск
Владивосток           | Москва
Владивосток           | Хабаровск
Комсомольск−на−Амуре  | Екатеринбург
Хабаровск             | Анадырь
Хабаровск             | Благовещенск
Хабаровск             | Владивосток
Хабаровск             | Москва
Хабаровск             | Санкт−Петербург
Хабаровск             | Усть−Илимск
Хабаровск             | Южно−Сахалинск
(11 строк)
```

Функция get_routes_occupation имеет четыре параметра: названия городов
отправления и прибытия, а также даты начала и конца отчетного периода.
Значения всех аргументов, кроме первого, сформируем с помощью функций
list_connected_cities и unnest. Нам пришлось сделать два вызова функции
unnest, потому что получать несколько аргументов-массивов она может только
при использовании в предложении FROM.

```sql
SELECT get_routes_occupation(
city,
list_connected_cities( city ),
unnest( ARRAY[ '2017-07-16', '2017-08-01' ]::date[] ),
unnest( ARRAY[ '2017-07-31', '2017-08-15' ]::date[] )
)
FROM airports
WHERE timezone = 'Asia/Vladivostok'
ORDER BY city;
```

Выведем результат в виде составных значений. Обратите внимание на порядок
вывода строк: полеты «туда» и «обратно» идут парами.

```text
get_routes_occupation
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
(Владивосток,Иркутск,79,700,0.11)
(Иркутск,Владивосток,82,750,0.11)
(Владивосток,Москва,461,3108,0.15)
(Москва,Владивосток,567,3108,0.18)
(Екатеринбург,Комсомольск−на−Амуре,31,444,0.07)
(Комсомольск−на−Амуре,Екатеринбург,120,1110,0.11)
(Анадырь,Хабаровск,45,116,0.39)
(Хабаровск,Анадырь,17,116,0.15)
(Благовещенск,Хабаровск,639,1358,0.47)
(Хабаровск,Благовещенск,622,1358,0.46)
(10 строк)
```

Всего получено 10 строк, хотя предполагалось 44: полеты по одиннадцати направлениям совершаются «туда» и «обратно», при этом отчет формируется за
два периода. Прояснить причину столь неожиданного результата нам поможет
следующий запрос, который показывает, какие аргументы получает функция
get_routes_occupation:

```sql
SELECT
city,
list_connected_cities( city ),
unnest( ARRAY[ '2017-07-16', '2017-08-01' ]::date[] ),
unnest( ARRAY[ '2017-07-31', '2017-08-15' ]::date[] )
FROM airports
WHERE timezone = 'Asia/Vladivostok'
ORDER BY 1, 2, 3, 4;
```

При вызове табличной функции непосредственно в списке SELECT число строк,
попадающих в выборку, зависит от числа строк, возвращаемых функцией для
каждой исходной строки, отобранной в предложении FROM с учетом условия
WHERE. Если функция возвращает N строк, то в выборку идет N строк, при этом
значения столбцов, представленных в списке SELECT, будут в этих строках дублироваться. В нашем примере дублируются значения столбца city. Если же
функция не возвращает ни одной строки, то и в выборку не попадает ни одной
строки — исходная строка «исчезает», и результат может оказаться неполным.

В подразделе документации 36.5.9 «Функции SQL, возвращающие множества»
сказано, что функции, вызываемые в списке SELECT, всегда вычисляются таким
образом, как будто они размещены во внутреннем цикле конструкции Nested

Loop, во внешнем цикле которой идет перебор строк, порождаемых в предложении FROM. Поэтому функции вычисляются до полного завершения, прежде чем
будет взята следующая строка из внешнего набора строк.

В выборке есть значения NULL. Причина их появления уже обсуждалась выше.
Только в пяти строках эти значения отсутствуют. Для каждой из них функция
get_routes_occupation возвращает по две строки, что в результате и дает всего
десять строк.

```text
city                  | list_connected_cities | unnest     | unnest
−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−−
Владивосток           | Иркутск               | 2017−07−16 | 2017−07−31
Владивосток           | Москва                | 2017−08−01 | 2017−08−15
Владивосток           | Хабаровск             |            |
Комсомольск−на−Амуре  | Екатеринбург          | 2017−07−16 | 2017−07−31
Комсомольск−на−Амуре  |                       | 2017−08−01 | 2017−08−15
Хабаровск             | Анадырь               | 2017−07−16 | 2017−07−31
Хабаровск             | Благовещенск          | 2017−08−01 | 2017−08−15
Хабаровск             | Владивосток           |            |
Хабаровск             | Москва                |            |
Хабаровск             | Санкт−Петербург       |            |
Хабаровск             | Усть−Илимск           |            |
Хабаровск             | Южно−Сахалинск        |            |
(12 строк)
```

Из условия следует, что для получения правильного результата нам нужно было
каждый маршрут, то есть пару городов, скомбинировать со всеми временны́ми
интервалами. Задачу легко выполнить, вызывая функции в предложении FROM,
но сделать это в списке SELECT — нетривиальная задача. В результате в предыдущем запросе функция get_routes_occupation вызывается не со всеми требуемыми комбинациями аргументов, что и приводит к некорректному результату.

**Задание 1**. Выше был рассмотрен следующий запрос:

```sql
SELECT get_routes_occupation(
city,
list_connected_cities( city ),
unnest( ARRAY[ '2017-07-16', '2017-08-01' ]::date[] ),
unnest( ARRAY[ '2017-07-31', '2017-08-15' ]::date[] )
)
FROM airports
WHERE timezone = 'Asia/Vladivostok'
ORDER BY city;
```

Попробуйте объяснить порядок вывода строк, полученный в результате его выполнения. Обратитесь к плану запроса, найдите в нем узел Sort.

Указание. За справкой можно обратиться к подразделу «Список SELECT» описания команды SELECT, приведенного в документации. Там сказано, когда должны вычисляться выражения в выходном списке SELECT при наличии в запросе
предложений DISTINCT, ORDER BY или LIMIT.

**Задание 2**. Выполните модифицированный запрос, в котором формируются отдельные столбцы, а не составные значения:

```sql
SELECT (
get_routes_occupation(
city,
list_connected_cities( city ),
unnest( ARRAY[ '2017-07-16', '2017-08-01' ]::date[] ),
unnest( ARRAY[ '2017-07-31', '2017-08-15' ]::date[] )
)
).*
FROM airports
WHERE timezone = 'Asia/Vladivostok'
ORDER BY 1, 2;
```

В предложении ORDER BY заданы номера столбцов, чтобы не повторять здесь вызовы функции с указанием их имен таким образом:

```
...
ORDER BY
( get_routes_occupation( city, ... ) ).dep_city,
( get_routes_occupation( city, ... ) ).arr_city;
```

В каком порядке выводятся строки теперь? Почему? В узле Sort плана запроса
обратите внимание на выражения, соответствующие столбцам 1 и 2 из предложения ORDER BY

**Задание 3**. В подразделе «Список SELECT» описания команды SELECT, приведенного в документации, сказано, что выходные выражения, содержащие функции, возвращающие множества, фактически вычисляются до ограничения количества строк, так что LIMIT будет отбрасывать уже не исходные строки, а строки, выдаваемые функцией, возвращающей множество. Проиллюстрируйте это
положение документации на примере запросов, рассмотренных в упражнении.

**Задание 4.** В тексте упражнения был приведен вариант запроса, выводящего
списки городов в четыре колонки с вызовом функций в предложении FROM. Попробуйте детально разобраться в алгоритме его выполнения.

Указание. Примите к сведению следующее:

• предложение WITH ORDINALITY нумерует строки, возвращаемые функцией
list_connected_cities;
• агрегатная функция any_value возвращает одно из значений, входящих
в группу;
• предложение FILTER отбирает из группы ровно одну строку (точнее говоря,
не более одной, ведь число городов в группах не одинаковое).

Вопрос. Можно ли было вместо any_value воспользоваться какой-нибудь другой
агрегатной функцией, например min или avg?

Попутно заметим, что данная функция не может заменить функцию random,
когда требуется выбрать случайную строку. В качестве примера выполните следующие запросы несколько раз:
```sql
SELECT any_value( model )
FROM aircrafts;
SELECT model
FROM aircrafts
ORDER BY random()
LIMIT 1;
```

<div style="page-break-after: always;"></div>

### Решение

Ответ на **задание 1**:
Порядок вывода строк определяется ORDER BY city. Сначала выводятся все результаты для «Владивосток», затем для «Комсомольск-на-Амуре», потом для «Хабаровск». Внутри каждой группы порядок строк от `get_routes_occupation` случаен, так как функция не гарантирует сортировку. 

- Узел Sort сортирует по ((ml.city ->> lang())) — это city из таблицы airports.
- Сортировка происходит до вычисления функций list_connected_cities и unnest (они в узле ProjectSet выше).
- Поэтому в результате строки сгруппированы по city из airports, а внутри группы порядок случаен.

<img src="./assets/2026-02-09 191714.jpg" width="700"> 

По **заданию 2** выполним запрос и посмотрим порядок вывода.

<img src="./assets/2026-02-09 192910.jpg" width="700">

Порядок изменился, потому что ORDER BY 1, 2 сортирует по dep_city и arr_city из результата функции, а не по исходному city.

По **Заданию 3** выполним два запроса с `LIMIT` и без.

```sql
-- Без LIMIT
SELECT city, list_connected_cities(city) AS connected_city
FROM airports
WHERE timezone = 'Asia/Vladivostok'
ORDER BY city, connected_city;
```
```sql
-- С LIMIT 3
SELECT city, list_connected_cities(city) AS connected_city
FROM airports
WHERE timezone = 'Asia/Vladivostok'
ORDER BY city, connected_city
LIMIT 3;
```

<img src="./assets/2026-02-09 193401.jpg" width="700"> 

Разбор алгоритма запроса из **задания 4**

```sql
WITH cities(col, city, num) AS
( SELECT 1, *
FROM list_connected_cities( 'Томск' ) WITH ORDINALITY
UNION ALL
SELECT 2, *
FROM list_connected_cities( 'Красноярск' ) WITH ORDINALITY
UNION ALL
...
)

SELECT num,
any_value( city ) FILTER ( WHERE col = 1 ) AS "Томск",
any_value( city ) FILTER ( WHERE col = 2 ) AS "Красноярск",
...
FROM cities
GROUP BY num
ORDER BY num;
```

- `WITH ORDINALITY` нумерует строки, возвращаемые функцией `list_connected_cities`. Возвращает `(city, ordinality)`.

- `SELECT 1, *` — добавляет колонку `col = 1` для Томска, затем `col = 2` для Красноярска и т.д.

- `UNION ALL` объединяет все списки в одну таблицу `citie`s с колонками:
`col` (номер города-источника), `city` (город назначения), `num` (порядковый номер внутри списка).

- В основном запросе группировка `GROUP BY` num — группирует строки с одинаковым порядковым номером `num` (т.е. первые города из каждого списка, вторые и т.д.).

- `any_value(city) FILTER (WHERE col = 1)` — для каждой группы берёт значение `city`, где `col = 1` (т.е. из списка Томска), если такое есть. Если нет (список короче) — возвращает `NULL`. Аналогично для других `col`.

- `ORDER BY num` — сортирует по порядковому номеру строки в исходных списках.

Итог: строки «выравниваются» по вертикали: первые города всех списков образуют первую строку результата, вторые — вторую и т.д., пропуски заполняются NULL.

Поскольку `FILTER` отбирает не более одной строки на группу (`col` уникален в пределах группы num), то `min(city)` даст то же значение, что и `any_value(city)`. Разницы в результате не будет. Но семантически `any_value` яснее — «возьми любое значение», а `min` — «возьми минимальное»

Выполним оба запроса несколько раз, чтобы подтвердить, что any_value не даёт случайную строку, а возвращает одно и то же значение при повторных вызовах

```sql
-- Запрос 1: any_value
SELECT any_value(model) FROM aircrafts;

-- Запрос 2: random + LIMIT 1
SELECT model FROM aircrafts ORDER BY random() LIMIT 1;
```

<img src="./assets/2026-02-09 194437.jpg" width="700"> 

`any_value(model)` каждый раз возвращает одно и то же значение («Боинг 777-300»). Это не случайная выборка, а часто первое, которое попалось при сканировании.

`ORDER BY random() LIMIT 1` каждый раз возвращает разные модели, потому что строки перемешиваются случайно перед выбором первой.