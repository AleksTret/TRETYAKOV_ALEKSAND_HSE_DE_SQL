# Домашнее задание 2

**Выполнил - Третьяков Александр Юрьевич**

## Упражение 18

### Задание

Использование условия
в определении раздела
В тексте подраздела 3.4.3 «Совместное использование оконных и агрегатных
функций» (с. 173) шла речь об оценке загрузки электронной системы бронирования билетов в выходные дни по сравнению с рабочими днями.

Средние значения, вычисленные для рабочих дней, выводились в столбце
avg_5_days и для выходных дней (в строках, где в столбце dow стоят значения 6
и 7). Аналогично средние значения, вычисленные для выходных дней, выводились в столбце avg_7_days и для рабочих дней (в тех строках, где в столбце dow
стоят значения от 1 до 5).

Запрос был таким:
```sql
SELECT
    to_char( date_trunc( 'day', b.book_date ), 'YYYY-MM-DD' ) AS b_date,
    -- b.book_date::date AS b_date, -- можно сделать и так
    extract( week FROM b.book_date ) AS week,
    extract( isodow FROM b.book_date ) AS dow,
    count( * ) AS day_tf_count,
    round( avg( count( * ) )  FILTER ( WHERE extract( isodow FROM book_date ) BETWEEN 1 AND 5 )  OVER week_win,  0 ) AS avg_5_days,
    round(  avg( count( * ) ) FILTER ( WHERE extract( isodow FROM book_date ) IN ( 6, 7 ) ) OVER week_win,  0 ) AS avg_67 -- выходные дни
FROM bookings b
JOIN tickets t ON t.book_ref = b.book_ref
JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
GROUP BY b_date, week, dow
    WINDOW week_win AS ( PARTITION BY extract( week FROM b.book_date ) )
ORDER BY b_date;
```
```text
b_date      | week | dow | day_tf_count | avg_5_days | avg_67
−−−−−−−−−−−−+−−−−−−+−−−−−+−−−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−
2017−06−21  | 25   | 3   | 20           | 41         | 494
2017−06−22  | 25   | 4   | 22           | 41         | 494
2017−06−23  | 25   | 5   | 80           | 41         | 494
2017−06−24  | 25   | 6   | 284          | 41         | 494
2017−06−25  | 25   | 7   | 704          | 41         | 494
2017−06−26  | 26   | 1   | 1323         | 5187       | 14684
2017−06−27  | 26   | 2   | 2639         | 5187       | 14684
2017−06−28  | 26   | 3   | 4295         | 5187       | 14684
2017−06−29  | 26   | 4   | 7408         | 5187       | 14684
2017−06−30  | 26   | 5   | 10269        | 5187       | 14684
...
2017−08−10  | 32   | 4   | 24656        | 23944      | 25666
2017−08−11  | 32   | 5   | 25344        | 23944      | 25666
2017−08−12  | 32   | 6   | 25109        | 23944      | 25666
2017−08−13  | 32   | 7   | 26222        | 23944      | 25666
2017−08−14  | 33   | 1   | 27459        | 26499      |
2017−08−15  | 33   | 2   | 25538        | 26499      |
(56 строк)
```

Можно изменить эту ситуацию, добавив в предложение PARTITION BY, отвечающее за определение разделов, еще один вычисляемый столбец — проверку
условия:
```sql
...
WINDOW week_win AS
( PARTITION BY
extract( week FROM book_date ),
extract( isodow FROM book_date ) IN ( 6, 7 )
)
...
```
```txt
b_date      | week | dow | day_tf_count | avg_5_days | avg_67
−−−−−−−−−−−−+−−−−−−+−−−−−+−−−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−
2017−06−21  | 25   | 3   | 20           | 41         |
2017−06−22  | 25   | 4   | 22           | 41         |
2017−06−23  | 25   | 5   | 80           | 41         |
2017−06−24  | 25   | 6   | 284          |            | 494
2017−06−25  | 25   | 7   | 704          |            | 494
2017−06−26  | 26   | 1   | 1323         | 5187       |
2017−06−27  | 26   | 2   | 2639         | 5187       |
2017−06−28  | 26   | 3   | 4295         | 5187       |
2017−06−29  | 26   | 4   | 7408         | 5187       |
2017−06−30  | 26   | 5   | 10269        | 5187       |
2017−07−01  | 26   | 6   | 13398        |            | 14684
2017−07−02  | 26   | 7   | 15969        |            | 14684
...
(56 строк)
```
Задание 1. Попробуйте объяснить механизм получения такого результата.

Задание 2. Поскольку теперь разделы формируются с учетом вида дней недели,
нельзя ли обойтись без использования предложений FILTER? Сначала сделайте
обоснованное предположение, а затем проверьте его практически и объясните
полученные результаты

<div style="page-break-after: always;"></div>

### Решение

#### Задание 1

Объяснение получения результата:

Добавление `extract(isodow FROM book_date) IN (6,7)` в `PARTITION BY` разделяет данные на два раздела внутри каждой недели:

В раздел `FALSE` - рабочие дни (сюда попадают строки, где `dow = 1-5`) и в раздел `TRUE` - выходные дни (`dow = 6,7`)

Затем для строки рабочего дня (раздел `FALSE`):
- `FILTER (WHERE dow BETWEEN 1 AND 5)` включает все строки раздела и вычисляет среднее по рабочим
- `FILTER (WHERE dow IN (6,7))` не включает ни одной строки (в разделе нет выходных) и возвращает `NULL`

А для строки выходного дня (раздел `TRUE`):
- `FILTER (WHERE dow BETWEEN 1 AND 5)` не включает строки = `NULL`
- `FILTER (WHERE dow IN (6,7))` включает все строки раздела среднее по выходным

В результате мы имеем что в рабочих днях отображается только `avg_5_days`, в выходных - только `avg_67`.

#### Задание 2

Без `FILTER` обойтись нельзя, если нужно сохранить тот же формат вывода (с `NULL` в "чужих" столбцах). Иначе оба столбца будут показывать одно и то же значение.
`FILTER` в оконных функциях с агрегатами — это возможность для условного агрегирования. 

Проверим запросом без `FILTER`

```sql
SELECT
    to_char(date_trunc('day', b.book_date), 'YYYY-MM-DD') AS b_date,
    extract(week FROM b.book_date) AS week,
    extract(isodow FROM b.book_date) AS dow,
    count(*) AS day_tf_count,
    round(avg(count(*)) OVER week_win, 0) AS avg_5_days,  
    round(avg(count(*)) OVER week_win, 0) AS avg_67       
FROM bookings b
JOIN tickets t ON t.book_ref = b.book_ref
JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
GROUP BY b_date, week, dow
WINDOW week_win AS (
    PARTITION BY
        extract(week FROM book_date),
        extract(isodow FROM book_date) IN (6,7)
)
ORDER BY b_date;
```

<img src="./assets/2026-01-30 201931.jpg" width="700"> 
